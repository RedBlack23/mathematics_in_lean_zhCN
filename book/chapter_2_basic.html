<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>基础 - translation of Mathematics in Lean</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter_1_introduction.html"><strong aria-hidden="true">1.</strong> 概述</a></li><li class="chapter-item expanded "><a href="chapter_2_basic.html" class="active"><strong aria-hidden="true">2.</strong> 基础</a></li><li class="chapter-item expanded "><a href="chapter_10_integration_and_measure_theory.html"><strong aria-hidden="true">3.</strong> 积分和测度论</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">translation of Mathematics in Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/RedBlack23/mathematics_in_lean_zhCN" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="2-基础部分"><a class="header" href="#2-基础部分">2 基础部分</a></h1>
<p>本章会介绍Lean中数学推理的具体细节: 计算, 使用引理和定理, 以及对一般结构的推理.</p>
<h2 id="21-计算"><a class="header" href="#21-计算">2.1 计算</a></h2>
<p>我们一般不把计算看成证明, 但是我们在验证每一个计算步骤的时候---正如lean要求我们做的那样, 说明左边等于右边的行为就是一个证明.</p>
<p>在Lean中, 陈述一个定理等价于确立一个证明该定理的目标. Lean提供<code>rewrite</code>策略, 缩写为<code>rw</code>, 用于在目标中实现等式代换, 把目标中出现在等式左边的项代换成右边的项. 如果<code>a</code>, <code>b</code>, <code>c</code>是实数, <code>mul_assoc a b c</code>是乘法结合律等式<code>a * b * c = a * (b * c)</code>, <code>mul_comm a b</code>是乘法交换律等式<code>a * b = b * a</code>. 在Lean中, 乘法是左结合的, 因此<code>mul_assoc</code>的左边也可以写为<code>（a * b）* c</code>. 然而通常情况下, 注意Lean的符号约定并在Lean也这样做时省略括号是很好的写作习惯. </p>
<p>让我们试一下<code>rw</code>:</p>
<pre><code class="language-lean">import Mathlib.Data.Real.Basic
example (a b c : ℝ) : a * b * c = b * (a * c) := by
  rw [mul_comm a b]
  rw [mul_assoc b a c]
</code></pre>
<p>开头的<code>import</code>从mathlib导入实数理论. 简洁起见后面的例子里在前面有过的情况下就不写<code>import</code>了.</p>
<p>自己试着改改看! <code>ℝ</code>字符写作<code>\R</code>或<code>\real</code>然后按下空格键或tab键. 如果你在读取Lean文件时将鼠标悬停在符号上, VScode将向你显示可用于输入该符号的语法. 如果键盘没有容易按到的反斜杠, 则可以通过更改<code>lean.input.leader</code>来更改转义字符设置. </p>
<p>当光标位于策略证明的中间时, Lean会在<em>Lean infoview</em>窗口中报告当前证明状态. 当你将光标移过证明的每一步时, 你可以看到状态的变化. Lean中的典型证明状态可能会是下面这样: </p>
<pre><code>1 goal
x y : ℕ,
h₁ : Prime x,
h₂ : ¬Even x,
h₃ : y &gt; x
⊢ y ≥ 4
</code></pre>
<p><code>⊢</code>前面的部分都是当前位置处我们所拥有的对象和假设, 称为语句集或者<em>语境</em>(context, 译者暂时并不知道这个词的标准译法). 本例中, 这里包含两个自然数对象<code>x</code>和<code>y</code>, 以及三个假设, 分别称作<code>h₁</code>,<code>h₂</code>,<code>h₃</code>(下标数字用<code>\1</code>,<code>\2</code>,<code>\3</code>等等来输入). Lean的语法要求在语境中每个假设都拥有一个名字, 叫什么都可以, 比如不下标的<code>h1</code>也可以. (实际上这是类型论的要求, 例如本例中<code>h₁</code>这个&quot;名字&quot;其实标记着类型为命题<code>Prime x</code>的项.)最后一行代表在当前状态下要证明的目标. 对于目标这个词, 一些人可能也会把整个Lean infoview的输出称为目标, 不过在特定上下文中不致混淆.</p>
<p>接下来做一些练习! 用<code>rw</code>策略替换掉下面的<code>sorry</code>. 为此再告诉你一个新技巧: 你可以用左箭头<code>←</code>(\l)来调转一个等式的方向, 从而让<code>rw</code>从另一边做替换操作. 例如, <code>rw ← mul_assoc a b c</code>会把目标里的<code>a * (b * c)</code>替换成<code>a * b * c</code>. 注意这里指的是<code>mul_assoc</code>等式的从右到左，它与目标的左边或右边无关。</p>
<pre><code class="language-lean">example (a b c : ℝ) : c * b * a = b * (a * c) := by
  sorry

example (a b c : ℝ) : a * (b * c) = b * (a * c) := by
  sorry
</code></pre>
<p>你也可以不带参数使用诸如<code>mul_assoc</code>或者<code>mul_comm</code>这些等式. 这些情况下rewrite策略会识别它在目标中遇到的第一个匹配模式.</p>
<pre><code class="language-lean">example (a b c : ℝ) : a * b * c = b * c * a := by
  rw [mul_assoc]
  rw [mul_comm]
</code></pre>
<p>你还可以只提供一部分参数, 例如<code>mul_comm a</code>识别所有形如<code>a * ?</code>或者<code>? * a</code>的模式. 下面的练习中你可以试试在第一个里面不给参数, 第二个里面只给一个参数.</p>
<pre><code class="language-lean">example (a b c : ℝ) : a * (b * c) = b * (c * a) := by
  sorry

example (a b c : ℝ) : a * (b * c) = b * (a * c) := by
  sorry
</code></pre>
<p>你也可以<code>rw</code>局部语句集里的条件:</p>
<pre><code class="language-lean">example (a b c d e f : ℝ) (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h']
  rw [← mul_assoc]
  rw [h]
  rw [mul_assoc]
</code></pre>
<p>试试看:
(第二个练习里面你可以使用定理<code>sub_self</code>, <code>sub_self a</code>代表等式<code>a - a = 0</code>.)</p>
<pre><code class="language-lean">example (a b c d e f : ℝ) (h : b * c = e * f) : a * b * c * d = a * e * f * d := by
  sorry

example (a b c d : ℝ) (hyp : c = b * a - d) (hyp' : d = a * b) : c = 0 := by
  sorry
</code></pre>
<p>现在我们介绍Lean的一些有用的特性. 首先, 通过在方括号内列出相关等式, 可以用一行rewrite执行多个命令.</p>
<pre><code class="language-lean">example (a b c d e f : ℝ) (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h', ← mul_assoc, h, mul_assoc]
</code></pre>
<p>将光标放在rewrite列表中的任意逗号后, 仍然可以看到进度. </p>
<p>另一个技巧是我们可以在例子或定理之外一次性地声明变量. 当Lean在定理的陈述中看到它们时, 它会自动将它们包含进来. </p>
<pre><code class="language-lean">variable (a b c d e f : ℝ)

example (h : a * b = c * d) (h' : e = f) : a * (b * e) = c * (d * f) := by
  rw [h', ← mul_assoc, h, mul_assoc]
</code></pre>
<p>检查上述证明开头的策略状态, 可以发现Lean确实包含了相关变量, 而忽略了声明中没有出现的g. 我们可以把声明的范围放在一个<code>section ... end</code>块中做成类似其他编程语言中局部变量的效果. 最后, 回顾一下第一章, Lean为我们提供了一个命令来确定表达式的类型:</p>
<pre><code class="language-lean">section
variable (a b c : ℝ)

#check a
#check a + b
#check (a : ℝ)
#check mul_comm a b
#check (mul_comm a b : a * b = b * a)
#check mul_assoc c a b
#check mul_comm a
#check mul_comm

end
</code></pre>
<p><code>#check</code>命令对对象和命题都有效。在响应命令<code>#check a</code>时，Lean报告<code>a</code>的类型为<code>ℝ</code>。作为对命令<code>#check mul_comm a b</code>的响应，Lean报告<code>mul_comm a b</code>是事实<code>a * b = b * a</code>的证明。命令<code>#check (a:ℝ)</code>表明我们期望<code>a</code>的类型是<code>ℝ</code>，如果不是这样，Lean将引发一个错误。稍后我们将解释最后三个<code>#check</code>命令的输出，但与此同时，您可以查看它们，并尝试使用您自己的一些<code>#check</code>命令。</p>
<p>我们再举几个例子。定理<code>two_mul a</code>表示<code>2 * a = a + a</code>。定理<code>add_mul</code>和<code>mul_add</code>表示乘法对加法的分配性，定理<code>add_assoc</code>表示加法的结合律。使用<code>#check</code>命令查看精确的语句。</p>
<pre><code class="language-lean">example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b := by
  rw [mul_add, add_mul, add_mul]
  rw [← add_assoc, add_assoc (a * a)]
  rw [mul_comm b a, ← two_mul]
</code></pre>
<p>虽然可以通过在编辑器中逐步检查来弄清楚这个证明中发生了什么，但很难单独阅读。Lean使用<code>calc</code>关键字提供了一种更结构化的方法来编写类似这样的证明。</p>
<pre><code class="language-lean">example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b :=
  calc
    (a + b) * (a + b) = a * a + b * a + (a * b + b * b) := by
      rw [mul_add, add_mul, add_mul]
    _ = a * a + (b * a + a * b) + b * b := by
      rw [← add_assoc, add_assoc (a * a)]
    _ = a * a + 2 * (a * b) + b * b := by
      rw [mul_comm b a, ← two_mul]
</code></pre>
<p>以<code>calc</code>开头的表达式是一个证明项。<code>calc</code>表达式也可以在策略证明块中使用，Lean将其解释为使用证明项的结果来解决当前目标的指令。<code>calc</code>语法很挑剔，必须严格仿照上例格式使用下划线和对齐。Lean使用缩进来确定策略块或<code>calc</code>块开始和结束的地方。试着改变上面证明中的缩进，看看会发生什么。
<em>译者注--改变缩进好像没什么关系</em></p>
<p>编写<code>calc</code>证明的一种方法是首先使用<code>sorry</code>策略填空，确保Lean接受中间步骤表达式，然后使用策略对各个步骤进行论证。</p>
<pre><code class="language-lean">example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b :=
  calc
    (a + b) * (a + b) = a * a + b * a + (a * b + b * b) := by
      sorry
    _ = a * a + (b * a + a * b) + b * b := by
      sorry
    _ = a * a + 2 * (a * b) + b * b := by
      sorry
</code></pre>
<p>试试用两种方法证明以下等式：只用<code>rw</code>和用更结构化的<code>calc</code>。</p>
<pre><code class="language-lean">example : (a + b) * (c + d) = a * c + a * d + b * c + b * d := by
  sorry
</code></pre>
<p>下面的练习有点挑战性。你可以用下面列出的定理。</p>
<pre><code class="language-lean">example (a b : ℝ) : (a + b) * (a - b) = a ^ 2 - b ^ 2 := by
  sorry

#check pow_two a
#check mul_sub a b c
#check add_mul a b c
#check add_sub a b c
#check sub_sub a b c
#check add_zero a
</code></pre>
<p>我们还可以在语句集中的假设中执行重写。例如，<code>rw [mul_comm a b] at hyp</code>将假设<code>hyp</code>中的<code>a * b</code>替换为<code>b * a</code>。</p>
<pre><code class="language-lean">example (a b c d : ℝ) (hyp : c = d * a + b) (hyp' : b = a * d) : c = 2 * a * d := by
  rw [hyp'] at hyp
  rw [mul_comm d a] at hyp
  rw [← two_mul (a * d)] at hyp
  rw [← mul_assoc 2 a d] at hyp
  exact hyp
</code></pre>
<p>最后一步中<code>exact</code>策略使用<code>hyp</code>来解决目标的原理是，到此<code>hyp</code>已经是目标本身了。</p>
<p>最后我们介绍一个Mathlib提供的强力自动化工具<code>ring</code>策略，它专门用来解决交换环中的等式，只要这些等式是完全由环公理导出的而不涉及别的假设。</p>
<pre><code class="language-lean">example : c * b * a = b * (a * c) := by
  ring

example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b := by
  ring

example : (a + b) * (a - b) = a ^ 2 - b ^ 2 := by
  ring

example (hyp : c = d * a + b) (hyp' : b = a * d) : c = 2 * a * d := by
  rw [hyp, hyp']
  ring
</code></pre>
<p><code>ring</code>策略通过<code>import Mathlib.Data.Real.Basic</code>导入，但下一节会看到它不止可以用在实数的计算上。它还可以通过<code>import Mathlib.Tactic</code>导入。我们会看到，对于其他常见的代数结构也有类似的策略。</p>
<p><code>rw</code>有一种叫做<code>nth_rewrite</code>的变体，允许你替换目标表达式中具体到某个实例。匹配项从1开始计数，在下面的例子中<code>nth_rewrite 2 h</code>用<code>c</code>替换了第二个<code>a + b</code>。</p>
<pre><code class="language-lean">example (a b c : ℕ) (h : a + b = c) : (a + b) * (a + b) = a * c + b * c := by
  nth_rw 2 [h]
  rw [add_mul]
</code></pre>
<h2 id="22-证明代数结构中的等式"><a class="header" href="#22-证明代数结构中的等式">2.2. 证明代数结构中的等式</a></h2>
<p>数学中，环由一个对象集合$R$、运算$+ ×$、常数$0,1$、求逆运算$x ↦ -x$并满足：</p>
<ul>
<li>$R$与$+$构成阿贝尔群，$0$是加法单位元，负数是逆。</li>
<li>$1$是乘法单位元，乘法满足结合律和对加法的分配律。</li>
</ul>
<p>在Lean中，对象集合被表示为类型<code>R</code>。环公理如下:</p>
<pre><code class="language-lean">variable (R : Type*) [Ring R]

#check (add_assoc : ∀ a b c : R, a + b + c = a + (b + c))
#check (add_comm : ∀ a b : R, a + b = b + a)
#check (zero_add : ∀ a : R, 0 + a = a)
#check (add_left_neg : ∀ a : R, -a + a = 0)
#check (mul_assoc : ∀ a b c : R, a * b * c = a * (b * c))
#check (mul_one : ∀ a : R, a * 1 = a)
#check (one_mul : ∀ a : R, 1 * a = a)
#check (mul_add : ∀ a b c : R, a * (b + c) = a * b + a * c)
#check (add_mul : ∀ a b c : R, (a + b) * c = a * c + b * c)
</code></pre>
<p>一会儿再讲第一行的方括号是什么意思，现在你只需要知道我们声明了一个类型<code>R</code>和<code>R</code>上的环结构。这样我们就可以表示一般的环中的元素并使用环的定理库。</p>
<p>前一节用过上面的一些定理，所以你应该感觉很熟悉。Lean不止能在例如自然数和整数这样具体的数学结构上证明东西，也可以在环这样抽象的公理化的结构上证明东西。Lean支持抽象和具体结构的通用推理，并且有能力识别符合公理的实例。任何关于环的定理都可以应用于具体的环，如整数<code>ℤ</code>、有理数<code>ℚ</code>、复数<code>ℂ</code>，和抽象的环，如任何有序环或任何域。</p>
<p>然而，并不是所有实数的重要性质在任意环中都成立。例如，实数乘法是可交换的，但一般情况下并不成立。例如实数矩阵构成的环的乘法通常不能交换。如果我们声明<code>R</code>是一个交换环<code>CommRing</code>，上一节中的所有关于<code>ℝ</code>定理在<code>R</code>中仍然成立。</p>
<pre><code class="language-lean">variable (R : Type*) [CommRing R]
variable (a b c d : R)

example : c * b * a = b * (a * c) := by ring

example : (a + b) * (a + b) = a * a + 2 * (a * b) + b * b := by ring

example : (a + b) * (a - b) = a ^ 2 - b ^ 2 := by ring

example (hyp : c = d * a + b) (hyp' : b = a * d) : c = 2 * a * d := by
  rw [hyp, hyp']
  ring
</code></pre>
<p>别的证明也都不需要变，你可以自己试试看。当证明很短时，比如你只用了一个<code>ring</code>或者<code>linarith</code>或者<code>sorry</code>，你可以把它们写进<code>by</code>的同一行里。好的证明写手需要平衡简洁性和可读性。</p>
<p>本节里面我们会证明更多环定理，它们基本上都在Mathlib里面，看完这一节你会对Mathlib里面的东西更熟悉。同时这也是训练你的证明能力。</p>
<p>Lean提供了类似于别的编程语言中的“局域变量”的变量名组织机制。通过命令<code>namespace bar</code>创建一个命名空间<code>bar</code>并引入定义或者定理<code>foo</code>，你在命名空间外面引用它时全名为<code>bar.foo</code>。命令<code>open bar</code>可以打开这个命名空间，此时你可以用短名字<code>foo</code>。下面我们为了不与Mathlib中的定理名冲突，我们打开一个名为<code>MyRing</code>的命名空间。</p>
<p>下面的例子证明了<code>add_zero</code>和<code>add_right_neg</code>，所以它们不需要作为环公理。</p>
<pre><code class="language-lean">namespace MyRing
variable {R : Type*} [Ring R]

theorem add_zero (a : R) : a + 0 = a := by rw [add_comm, zero_add]

theorem add_right_neg (a : R) : a + -a = 0 := by rw [add_comm, add_left_neg]

#check MyRing.add_zero
#check add_zero

end MyRing
</code></pre>
<p>我们重新证明了库中的定理，但是我们可以继续使用库中的版本。但是下面的练习中请不要作弊，我们只能用我们之前证明过的定理。</p>
<p>(如果你仔细注意的话，你可能已经注意到我们把<code>(R: Type*)</code>中的圆括号改成了<code>{R: Type*}</code>中的花括号。这里声明<code>R</code>是一个<em>隐式参数</em>。稍后会解释这意味着什么。)</p>
<p>下面这个定理很有用：</p>
<pre><code class="language-lean">theorem neg_add_cancel_left (a b : R) : -a + (a + b) = b := by
  rw [← add_assoc, add_left_neg, zero_add]
</code></pre>
<p>证明它的配套版本：</p>
<pre><code class="language-lean">theorem add_neg_cancel_right (a b : R) : a + b + -b = a := by
  sorry
</code></pre>
<p>然后用它们证明下面几个（最佳方案仅需三次重写）：</p>
<pre><code class="language-lean">theorem add_left_cancel {a b c : R} (h : a + b = a + c) : b = c := by
  sorry

theorem add_right_cancel {a b c : R} (h : a + b = c + b) : a = c := by
  sorry
</code></pre>
<p>现在解释一下花括号的意思。假设你现在语句集里面拥有变量<code>a</code>、<code>b</code>、<code>c</code>和一个假设<code>h : a + b = a + c</code>，然后你想得到结论<code>b = c</code>。在Lean中，定理可以应用于假设和事实，就像将它们应用于对象一样，因此你可能会认为<code>add_left_cancel a b c h</code>是事实<code>b = c</code>的证明。但其实明确地写出<code>a b c</code>是多余的，因为假设<code>h</code>的形式就限定了它们正是我们想使用的对象。现下输入几个额外的字符并不麻烦，但是更复杂的表达式中就会很繁琐。Lean支持把参数标记为隐式，这意味着它们可以且应该被省略，能通过后面的的命题和假设中推断出来。<code>{a b c: R}</code>中的花括号正是这种隐式参数标记。因此根据定理的表述，正确的表达式是<code>add_left_cancel h</code>。</p>
<p>下面演示个新玩意儿，让我们从环公理中证明a * 0 = 0。</p>
<pre><code class="language-lean">theorem mul_zero (a : R) : a * 0 = 0 := by
  have h : a * 0 + a * 0 = a * 0 + 0 := by
    rw [← mul_add, add_zero, add_zero]
  rw [add_left_cancel h]
</code></pre>
<p>你通过<code>have</code>策略引入了一个辅助性新目标，<code>a * 0 + a * 0 = a * 0 + 0</code>，与原始目标具有相同的语境。这个目标下的“子证明”块需要缩进。证出这个子目标之后我们就多了一个新的命题<code>h</code>，可以用于证明原目标。这里我们看到<code>add_left_cancel h</code>的结果恰好就是原目标。</p>
<p>我们同样可以使用<code>apply add_left_cancel h</code>或<code>exact add_left_cancel h</code>来结束证明。<code>exact</code>策略将能够完整证明当前目标的证明项作为参数，而不创建任何新目标。<code>apply</code>策略是一种变体，它的论证不一定是一个完整的证明。缺失的部分要么由Lean自动推断，要么成为需要证明的新目标。虽然<code>exact</code>策略在技术上是多余的，因为它严格来说不如<code>apply</code>强大，但它增加了可读性。</p>
<p>乘法不一定可交换，所以下面的定理也需要证。</p>
<pre><code class="language-lean">theorem zero_mul (a : R) : 0 * a = 0 := by
  sorry
</code></pre>
<p>更多练习：</p>
<pre><code class="language-lean">theorem neg_eq_of_add_eq_zero {a b : R} (h : a + b = 0) : -a = b := by
  sorry

theorem eq_neg_of_add_eq_zero {a b : R} (h : a + b = 0) : a = -b := by
  sorry

theorem neg_zero : (-0 : R) = 0 := by
  apply neg_eq_of_add_eq_zero
  rw [add_zero]

theorem neg_neg (a : R) : - -a = a := by
  sorry
</code></pre>
<p>我们必须在第三个定理中指定<code>(-0 : R)</code>, 因为Lean不知道我们想到的是哪个<code>0</code>，默认情况下它是自然数。</p>
<p>在Lean中，环上的减法等于加上加法的逆。</p>
<pre><code class="language-lean">example (a b : R) : a - b = a + -b :=
  sub_eq_add_neg a b
</code></pre>
<p>实数的减法就是被如此定义的，因此：</p>
<pre><code class="language-lean">example (a b : ℝ) : a - b = a + -b :=
  rfl

example (a b : ℝ) : a - b = a + -b := by
  rfl
</code></pre>
<p><code>rfl</code>是自反性（reflexivity）的缩写。第一个例子中当它作为<code>a - b = a + -b</code>的证明项，Lean展开定义并验证两边是相同的。第二个例子中<code>rfl</code>策略也是如此。这是在Lean的基础逻辑中所谓的定义相等的一个例子。这意味着不仅可以用<code>sub_eq_add_neg</code>重写来替换<code>a - b = a + -b</code>，而且在某些情况下，当处理实数时，您可以互换使用方程的两边。例如，您现在有足够的信息来证明上一节中的<code>self_sub</code>定理:</p>
<pre><code class="language-lean">theorem self_sub (a : R) : a - a = 0 := by
  sorry
</code></pre>
<p>你可以使用<code>rw</code>来证，不过如果不是任意环<code>R</code>而是实数的话，你也可以用<code>apply</code>或者<code>exact</code>。</p>
<p>Lean知道<code>1 + 1 = 2</code>对任何环都成立。你可以用它来证明上一节中的定理<code>two_mul</code>。</p>
<pre><code class="language-lean">theorem one_add_one_eq_two : 1 + 1 = (2 : R) := by
  norm_num

theorem two_mul (a : R) : 2 * a = a + a := by
  sorry
</code></pre>
<p>上面的一些定理并不需要环结构甚至加法交换律，有群结构就够了，群公理是下面这些：</p>
<pre><code class="language-lean">variable (A : Type*) [AddGroup A]

#check (add_assoc : ∀ a b c : A, a + b + c = a + (b + c))
#check (zero_add : ∀ a : A, 0 + a = a)
#check (add_left_neg : ∀ a : A, -a + a = 0)
</code></pre>
<p>群运算可交换的话习惯上用加号(但是这只是习惯而已，<code>AddGroup</code>并不真的可交换)，否则用乘号。Lean提供乘法版本<code>Group</code>和加法版本<code>AddGroup</code>，以及它们的可交换版本<code>CommGroup</code>和<code>AddCommGroup</code>。</p>
<pre><code class="language-lean">variable {G : Type*} [Group G]

#check (mul_assoc : ∀ a b c : G, a * b * c = a * (b * c))
#check (one_mul : ∀ a : G, 1 * a = a)
#check (mul_left_inv : ∀ a : G, a⁻¹ * a = 1)
</code></pre>
<p>试试用这些群公理证明以下命题。你可以引入一些引理。</p>
<pre><code class="language-lean">theorem mul_right_inv (a : G) : a * a⁻¹ = 1 := by
  sorry

theorem mul_one (a : G) : a * 1 = a := by
  sorry

theorem mul_inv_rev (a b : G) : (a * b)⁻¹ = b⁻¹ * a⁻¹ := by
  sorry
</code></pre>
<p>一步一步用这些定理做证明非常麻烦，所以在这些代数结构上Mathlib提供了类似<code>ring</code>的策略：<code>group</code>用于非交换的乘法群，<code>abel</code>用于可交换加法群，<code>noncomm_ring</code>用于非交换环。代数结构<code>Ring</code>和<code>CommRing</code>分别对应的自动化策略被称做<code>noncomm_ring</code>和<code>ring</code>，这似乎很奇怪。这在一定程度上是由于历史原因，但也因为使用更短的名称来处理交换环的策略更方便，因为它使用得更频繁。</p>
<h2 id="23-使用定理和引理"><a class="header" href="#23-使用定理和引理">2.3. 使用定理和引理</a></h2>
<p>重写对于证明等式很有用，但是对于其他类型的定理呢？例如，我们如何证明一个不等式，比如在$b ≤ c$时$a + e ^ b ≤ a + e ^ c$？ 本节我们会着重使用<code>apply</code>和<code>exact</code>。</p>
<p>考虑库定理<code>le_refl</code>和<code>le_trans</code>：</p>
<pre><code class="language-lean">variable (a b c : ℝ)

#check (le_refl : ∀ a : ℝ, a ≤ a)
#check (le_trans : a ≤ b → b ≤ c → a ≤ c)
</code></pre>
<p><code>→</code>是右结合的，因此<code>le_trans</code>应该被解释为<code>a ≤ b → (b ≤ c → a ≤ c)</code>。详细规则在3.1节中解释。标准库设计者已经将<code>le_trans</code>中的<code>a</code>, <code>b</code>和<code>c</code>设置为隐式参数，也就是在使用时从语境中推断。(强制显式参数将在后面讨论)。例如，当假设<code>h : a ≤ b</code>和<code>h' : b ≤ c</code>在语句集中时，以下所有语句都有效:</p>
<pre><code class="language-lean">variable (h : a ≤ b) (h' : b ≤ c)

#check (le_refl : ∀ a : Real, a ≤ a)
#check (le_refl a : a ≤ a)
#check (le_trans : a ≤ b → b ≤ c → a ≤ c)
#check (le_trans h : b ≤ c → a ≤ c)
#check (le_trans h h' : a ≤ c)
</code></pre>
<p><code>apply</code>策略对一般陈述或暗示进行证明，试图将结论与当前目标相匹配，并将假设(如果有的话)作为新目标。如果给定的证明与目标完全匹配(模定义等式)，则可以使用<code>exact</code>策略而不是<code>apply</code>。所以，所有这些工作:</p>
<p>The apply tactic takes a proof of a general statement or implication, tries to match the conclusion with the current goal, and leaves the hypotheses, if any, as new goals. If the given proof matches the goal exactly (modulo definitional equality), you can use the exact tactic instead of apply. So, all of these work:</p>
<pre><code class="language-lean">example (x y z : ℝ) (h₀ : x ≤ y) (h₁ : y ≤ z) : x ≤ z := by
  apply le_trans
  · apply h₀
  . apply h₁

example (x y z : ℝ) (h₀ : x ≤ y) (h₁ : y ≤ z) : x ≤ z := by
  apply le_trans h₀
  apply h₁

example (x y z : ℝ) (h₀ : x ≤ y) (h₁ : y ≤ z) : x ≤ z :=
  le_trans h₀ h₁

example (x : ℝ) : x ≤ x := by
  apply le_refl

example (x : ℝ) : x ≤ x :=
  le_refl x
</code></pre>
<p>In the first example, applying le_trans creates two goals, and we use the dots to indicate where the proof of each begins. The dots are optional, but they serve to focus the goal: within the block introduced by the dot, only one goal is visible, and it must be completed before the end of the block. Here we end the first block by starting a new one with another dot. We could just as well have decreased the indentation. In the fourth example and in the last example, we avoid going into tactic mode entirely: le_trans h₀ h₁ and le_refl x are the proof terms we need.</p>
<p>Here are a few more library theorems:</p>
<pre><code class="language-lean">#check (le_refl : ∀ a, a ≤ a)
#check (le_trans : a ≤ b → b ≤ c → a ≤ c)
#check (lt_of_le_of_lt : a ≤ b → b &lt; c → a &lt; c)
#check (lt_of_lt_of_le : a &lt; b → b ≤ c → a &lt; c)
#check (lt_trans : a &lt; b → b &lt; c → a &lt; c)
</code></pre>
<p>利用这些定理和<code>apply</code>和<code>exact</code>策略来证明下面的问题：</p>
<pre><code class="language-lean">example (h₀ : a ≤ b) (h₁ : b &lt; c) (h₂ : c ≤ d) (h₃ : d &lt; e) : a &lt; e := by
  sorry
</code></pre>
<p>实际上Lean有一个自动化策略来证明这类问题：</p>
<pre><code class="language-lean">example (h₀ : a ≤ b) (h₁ : b &lt; c) (h₂ : c ≤ d) (h₃ : d &lt; e) : a &lt; e := by
  linarith
</code></pre>
<p><code>linarith</code>策略用于处理线性算术。</p>
<pre><code class="language-lean">example (h : 2 * a ≤ 3 * b) (h' : 1 ≤ a) (h'' : d = 2) : d + a ≤ 5 * b := by
  linarith
</code></pre>
<p>In addition to equations and inequalities in the context, linarith will use additional inequalities that you pass as arguments. In the next example, exp_le_exp.mpr h' is a proof of exp b ≤ exp c, as we will explain in a moment. Notice that, in Lean, we write f x to denote the application of a function f to the argument x, exactly the same way we write h x to denote the result of applying a fact or theorem h to the argument x. Parentheses are only needed for compound arguments, as in f (x + y). Without the parentheses, f x + y would be parsed as (f x) + y.</p>
<pre><code class="language-lean">example (h : 1 ≤ a) (h' : b ≤ c) : 2 + a + exp b ≤ 3 * a + exp c := by
  linarith [exp_le_exp.mpr h']
</code></pre>
<p>这里列出更多库定理，可以用于实数上的不等式：</p>
<pre><code class="language-lean">#check (exp_le_exp : exp a ≤ exp b ↔ a ≤ b)
#check (exp_lt_exp : exp a &lt; exp b ↔ a &lt; b)
#check (log_le_log : 0 &lt; a → 0 &lt; b → (log a ≤ log b ↔ a ≤ b))
#check (log_lt_log : 0 &lt; a → a &lt; b → log a &lt; log b)
#check (add_le_add : a ≤ b → c ≤ d → a + c ≤ b + d)
#check (add_le_add_left : a ≤ b → ∀ c, c + a ≤ c + b)
#check (add_le_add_right : a ≤ b → ∀ c, a + c ≤ b + c)
#check (add_lt_add_of_le_of_lt : a ≤ b → c &lt; d → a + c &lt; b + d)
#check (add_lt_add_of_lt_of_le : a &lt; b → c ≤ d → a + c &lt; b + d)
#check (add_lt_add_left : a &lt; b → ∀ c, c + a &lt; c + b)
#check (add_lt_add_right : a &lt; b → ∀ c, a + c &lt; b + c)
#check (add_nonneg : 0 ≤ a → 0 ≤ b → 0 ≤ a + b)
#check (add_pos : 0 &lt; a → 0 &lt; b → 0 &lt; a + b)
#check (add_pos_of_pos_of_nonneg : 0 &lt; a → 0 ≤ b → 0 &lt; a + b)
#check (exp_pos : ∀ a, 0 &lt; exp a)
#check add_le_add_left
</code></pre>
<p>Some of the theorems, exp_le_exp, exp_lt_exp, and log_le_log use a bi-implication, which represents the phrase “if and only if.” (You can type it in VS Code with \lr of \iff). We will discuss this connective in greater detail in the next chapter. Such a theorem can be used with rw to rewrite a goal to an equivalent one:</p>
<pre><code class="language-lean">example (h : a ≤ b) : exp a ≤ exp b := by
  rw [exp_le_exp]
  exact h
</code></pre>
<p>In this section, however, we will use the fact that if h : A ↔ B is such an equivalence, then h.mp establishes the forward direction, A → B, and h.mpr establishes the reverse direction, B → A. Here, mp stands for “modus ponens” and mpr stands for “modus ponens reverse.” You can also use h.1 and h.2 for h.mp and h.mpr, respectively, if you prefer. Thus the following proof works:</p>
<p>example (h₀ : a ≤ b) (h₁ : c &lt; d) : a + exp c + e &lt; b + exp d + e := by
apply add_lt_add_of_lt_of_le
· apply add_lt_add_of_le_of_lt h₀
apply exp_lt_exp.mpr h₁
apply le_refl
The first line, apply add_lt_add_of_lt_of_le, creates two goals, and once again we use a dot to separate the proof of the first from the proof of the second.</p>
<p>Try the following examples on your own. The example in the middle shows you that the norm_num tactic can be used to solve concrete numeric goals.</p>
<pre><code class="language-lean">example (h₀ : d ≤ e) : c + exp (a + d) ≤ c + exp (a + e) := by sorry

example : (0 : ℝ) &lt; 1 := by norm_num

example (h : a ≤ b) : log (1 + exp a) ≤ log (1 + exp b) := by
  have h₀ : 0 &lt; 1 + exp a := by sorry
  have h₁ : 0 &lt; 1 + exp b := by sorry
  apply (log_le_log h₀ h₁).mpr
  sorry
</code></pre>
<p>From these examples, it should be clear that being able to find the library theorems you need constitutes an important part of formalization. There are a number of strategies you can use:</p>
<p>You can browse Mathlib in its GitHub repository.</p>
<p>You can use the API documentation on the Mathlib web pages.</p>
<p>You can rely on Mathlib naming conventions and Ctrl-space completion in the editor to guess a theorem name (or Cmd-space on a Mac keyboard). In Lean, a theorem named A_of_B_of_C establishes something of the form A from hypotheses of the form B and C, where A, B, and C approximate the way we might read the goals out loud. So a theorem establishing something like x + y ≤ ... will probably start with add_le. Typing add_le and hitting Ctrl-space will give you some helpful choices. Note that hitting Ctrl-space twice displays more information about the available completions.</p>
<p>If you right-click on an existing theorem name in VS Code, the editor will show a menu with the option to jump to the file where the theorem is defined, and you can find similar theorems nearby.</p>
<p>You can use the apply? tactic, which tries to find the relevant theorem in the library.</p>
<p>example : 0 ≤ a ^ 2 := by
-- apply?
exact sq_nonneg a
To try out apply? in this example, delete the exact command and uncomment the previous line. Using these tricks, see if you can find what you need to do the next example:</p>
<p>example (h : a ≤ b) : c - exp b ≤ c - exp a := by
sorry
Using the same tricks, confirm that linarith instead of apply? can also finish the job.</p>
<p>Here is another example of an inequality:</p>
<p>example : 2 * a * b ≤ a ^ 2 + b ^ 2 := by
have h : 0 ≤ a ^ 2 - 2 * a * b + b ^ 2
calc
a ^ 2 - 2 * a * b + b ^ 2 = (a - b) ^ 2 := by ring
_ ≥ 0 := by apply pow_two_nonneg</p>
<p>calc
2 * a * b = 2 * a * b + 0 := by ring
_ ≤ 2 * a * b + (a ^ 2 - 2 * a * b + b ^ 2) :=
add_le_add (le_refl _) h
_ = a ^ 2 + b ^ 2 := by ring
Mathlib tends to put spaces around binary operations like * and ^, but in this example, the more compressed format increases readability. There are a number of things worth noticing. First, an expression s ≥ t is definitionally equivalent to t ≤ s. In principle, this means one should be able to use them interchangeably. But some of Lean’s automation does not recognize the equivalence, so Mathlib tends to favor ≤ over ≥. Second, we have used the ring tactic extensively. It is a real timesaver! Finally, notice that in the second line of the second calc proof, instead of writing by exact add_le_add (le_refl _) h, we can simply write the proof term add_le_add (le_refl _) h.</p>
<p>In fact, the only cleverness in the proof above is figuring out the hypothesis h. Once we have it, the second calculation involves only linear arithmetic, and linarith can handle it:</p>
<p>example : 2 * a * b ≤ a ^ 2 + b ^ 2 := by
have h : 0 ≤ a ^ 2 - 2 * a * b + b ^ 2
calc
a ^ 2 - 2 * a * b + b ^ 2 = (a - b) ^ 2 := by ring
_ ≥ 0 := by apply pow_two_nonneg
linarith
How nice! We challenge you to use these ideas to prove the following theorem. You can use the theorem abs_le'.mpr.</p>
<p>example : |a * b| ≤ (a ^ 2 + b ^ 2) / 2 := by
sorry</p>
<p>#check abs_le'.mpr
If you managed to solve this, congratulations! You are well on your way to becoming a master formalizer.</p>
<h2 id="24-apply和rw的更多例子"><a class="header" href="#24-apply和rw的更多例子">2.4. apply和rw的更多例子</a></h2>
<p><code>min</code>函数在实数中被下面这三个命题来描述：</p>
<pre><code class="language-lean">#check (min_le_left a b : min a b ≤ a)
#check (min_le_right a b : min a b ≤ b)
#check (le_min : c ≤ a → c ≤ b → c ≤ min a b)
</code></pre>
<p>Can you guess the names of the theorems that characterize max in a similar way?</p>
<p>Notice that we have to apply min to a pair of arguments a and b by writing min a b rather than min (a, b). Formally, min is a function of type ℝ → ℝ → ℝ. When we write a type like this with multiple arrows, the convention is that the implicit parentheses associate to the right, so the type is interpreted as ℝ → (ℝ → ℝ). The net effect is that if a and b have type ℝ then min a has type ℝ → ℝ and min a b has type ℝ, so min acts like a function of two arguments, as we expect. Handling multiple arguments in this way is known as currying, after the logician Haskell Curry.</p>
<p>The order of operations in Lean can also take some getting used to. Function application binds tighter than infix operations, so the expression min a b + c is interpreted as (min a b) + c. With time, these conventions will become second nature.</p>
<p>Using the theorem le_antisymm, we can show that two real numbers are equal if each is less than or equal to the other. Using this and the facts above, we can show that min is commutative:</p>
<pre><code class="language-lean">example : min a b = min b a := by
  apply le_antisymm
  · show min a b ≤ min b a
    apply le_min
    · apply min_le_right
    apply min_le_left
  · show min b a ≤ min a b
    apply le_min
    · apply min_le_right
    apply min_le_left
</code></pre>
<p>Here we have used dots to separate proofs of different goals. Our usage is inconsistent: at the outer level, we use dots and indentation for both goals, whereas for the nested proofs, we use dots only until a single goal remains. Both conventions are reasonable and useful. We also use the show tactic to structure the proof and indicate what is being proved in each block. The proof still works without the show commands, but using them makes the proof easier to read and maintain.</p>
<p>It may bother you that the proof is repetitive. To foreshadow skills you will learn later on, we note that one way to avoid the repetition is to state a local lemma and then use it:</p>
<pre><code class="language-lean">example : min a b = min b a := by
  have h : ∀ x y : ℝ, min x y ≤ min y x := by
    intro x y
    apply le_min
    apply min_le_right
    apply min_le_left
  apply le_antisymm
  apply h
  apply h
</code></pre>
<p>We will say more about the universal quantifier in Section 3.1, but suffice it to say here that the hypothesis h says that the desired inequality holds for any x and y, and the intro tactic introduces an arbitrary x and y to establish the conclusion. The first apply after le_antisymm implicitly uses h a b, whereas the second one uses h b a.</p>
<p>Another solution is to use the repeat tactic, which applies a tactic (or a block) as many times as it can.</p>
<pre><code class="language-lean">example : min a b = min b a := by
  apply le_antisymm
  repeat
    apply le_min
    apply min_le_right
    apply min_le_left
</code></pre>
<p>In any case, whether or not you use these tricks, we encourage you to prove the following:</p>
<pre><code class="language-lean">example : max a b = max b a := by
  sorry
example : min (min a b) c = min a (min b c) := by
  sorry
</code></pre>
<p>Of course, you are welcome to prove the associativity of max as well.</p>
<p>It is an interesting fact that min distributes over max the way that multiplication distributes over addition, and vice-versa. In other words, on the real numbers, we have the identity min a (max b c) ≤ max (min a b) (min a c) as well as the corresponding version with max and min switched. But in the next section we will see that this does not follow from the transitivity and reflexivity of ≤ and the characterizing properties of min and max enumerated above. We need to use the fact that ≤ on the real numbers is a total order, which is to say, it satisfies ∀ x y, x ≤ y ∨ y ≤ x. Here the disjunction symbol, ∨, represents “or”. In the first case, we have min x y = x, and in the second case, we have min x y = y. We will learn how to reason by cases in Section 3.5, but for now we will stick to examples that don’t require the case split.</p>
<p>Here is one such example:</p>
<pre><code class="language-lean">theorem aux : min a b + c ≤ min (a + c) (b + c) := by
  sorry
example : min a b + c = min (a + c) (b + c) := by
  sorry
</code></pre>
<p>It is clear that aux provides one of the two inequalities needed to prove the equality, but applying it to suitable values yields the other direction as well. As a hint, you can use the theorem add_neg_cancel_right and the linarith tactic.</p>
<p>Lean’s naming convention is made manifest in the library’s name for the triangle inequality:</p>
<pre><code class="language-lean">#check (abs_add : ∀ a b : ℝ, |a + b| ≤ |a| + |b|)
</code></pre>
<p>Use it to prove the following variant:</p>
<pre><code class="language-lean">example : |a| - |b| ≤ |a - b| :=
  sorry
end
</code></pre>
<p>See if you can do this in three lines or less. You can use the theorem sub_add_cancel.</p>
<p>Another important relation that we will make use of in the sections to come is the divisibility relation on the natural numbers, x ∣ y. Be careful: the divisibility symbol is not the ordinary bar on your keyboard. Rather, it is a unicode character obtained by typing | in VS Code. By convention, Mathlib uses dvd to refer to it in theorem names.</p>
<p>example (h₀ : x ∣ y) (h₁ : y ∣ z) : x ∣ z :=
dvd_trans h₀ h₁</p>
<p>example : x ∣ y * x * z := by
apply dvd_mul_of_dvd_left
apply dvd_mul_left</p>
<p>example : x ∣ x ^ 2 := by
apply dvd_mul_left
In the last example, the exponent is a natural number, and applying dvd_mul_left forces Lean to expand the definition of x^2 to x * x^1. See if you can guess the names of the theorems you need to prove the following:</p>
<p>example (h : x ∣ w) : x ∣ y * (x * z) + x ^ 2 + w ^ 2 := by
sorry
end
With respect to divisibility, the greatest common divisor, gcd, and least common multiple, lcm, are analogous to min and max. Since every number divides 0, 0 is really the greatest element with respect to divisibility:</p>
<p>variable (m n : ℕ)</p>
<p>#check (Nat.gcd_zero_right n : Nat.gcd n 0 = n)
#check (Nat.gcd_zero_left n : Nat.gcd 0 n = n)
#check (Nat.lcm_zero_right n : Nat.lcm n 0 = 0)
#check (Nat.lcm_zero_left n : Nat.lcm 0 n = 0)
See if you can guess the names of the theorems you will need to prove the following:</p>
<p>example : Nat.gcd m n = Nat.gcd n m := by
sorry
Hint: you can use dvd_antisymm, but if you do, Lean will complain that the expression is ambiguous between the generic theorem and the version Nat.dvd_antisymm, the one specifically for the natural numbers. You can use <em>root</em>.dvd_antisymm to specify the generic one; either one will work.</p>
<h2 id="25-证明proving-facts-about-algebraic-structures"><a class="header" href="#25-证明proving-facts-about-algebraic-structures">2.5. 证明Proving Facts about Algebraic Structures</a></h2>
<p>In Section 2.2, we saw that many common identities governing the real numbers hold in more general classes of algebraic structures, such as commutative rings. We can use any axioms we want to describe an algebraic structure, not just equations. For example, a partial order consists of a set with a binary relation that is reflexive and transitive, like ≤ on the real numbers. Lean knows about partial orders:</p>
<pre><code class="language-lean">variable {α : Type*} [PartialOrder α]
variable (x y z : α)

#check x ≤ y
#check (le_refl x : x ≤ x)
#check (le_trans : x ≤ y → y ≤ z → x ≤ z)
</code></pre>
<p>Here we are adopting the Mathlib convention of using letters like α, β, and γ (entered as \a, \b, and \g) for arbitrary types. The library often uses letters like R and G for the carries of algebraic structures like rings and groups, respectively, but in general Greek letters are used for types, especially when there is little or no structure associated with them.</p>
<p>Associated to any partial order, ≤, there is also a strict partial order, &lt;, which acts somewhat like &lt; on the real numbers. Saying that x is less than y in this order is equivalent to saying that it is less-than-or-equal to y and not equal to y.</p>
<pre><code class="language-lean">#check x &lt; y
#check (lt_irrefl x : ¬x &lt; x)
#check (lt_trans : x &lt; y → y &lt; z → x &lt; z)
#check (lt_of_le_of_lt : x ≤ y → y &lt; z → x &lt; z)
#check (lt_of_lt_of_le : x &lt; y → y ≤ z → x &lt; z)

example : x &lt; y ↔ x ≤ y ∧ x ≠ y :=
  lt_iff_le_and_ne
</code></pre>
<p>In this example, the symbol ∧ stands for “and,” the symbol ¬ stands for “not,” and x ≠ y abbreviates ¬ (x = y). In Chapter 3, you will learn how to use these logical connectives to prove that &lt; has the properties indicated.</p>
<p>A lattice is a structure that extends a partial order with operations ⊓ and ⊔ that are analogous to min and max on the real numbers:</p>
<pre><code class="language-lean">variable {α : Type*} [Lattice α]
variable (x y z : α)

#check x ⊓ y
#check (inf_le_left : x ⊓ y ≤ x)
#check (inf_le_right : x ⊓ y ≤ y)
#check (le_inf : z ≤ x → z ≤ y → z ≤ x ⊓ y)
#check x ⊔ y
#check (le_sup_left : x ≤ x ⊔ y)
#check (le_sup_right : y ≤ x ⊔ y)
#check (sup_le : x ≤ z → y ≤ z → x ⊔ y ≤ z)
</code></pre>
<p>The characterizations of ⊓ and ⊔ justify calling them the greatest lower bound and least upper bound, respectively. You can type them in VS code using \glb and \lub. The symbols are also often called then infimum and the supremum, and Mathlib refers to them as inf and sup in theorem names. To further complicate matters, they are also often called meet and join. Therefore, if you work with lattices, you have to keep the following dictionary in mind:</p>
<p>⊓ is the greatest lower bound, infimum, or meet.</p>
<p>⊔ is the least upper bound, supremum, or join.</p>
<p>Some instances of lattices include:</p>
<p>min and max on any total order, such as the integers or real numbers with ≤</p>
<p>∩ and ∪ on the collection of subsets of some domain, with the ordering ⊆</p>
<p>∧ and ∨ on boolean truth values, with ordering x ≤ y if either x is false or y is true</p>
<p>gcd and lcm on the natural numbers (or positive natural numbers), with the divisibility ordering, ∣</p>
<p>the collection of linear subspaces of a vector space, where the greatest lower bound is given by the intersection, the least upper bound is given by the sum of the two spaces, and the ordering is inclusion</p>
<p>the collection of topologies on a set (or, in Lean, a type), where the greatest lower bound of two topologies consists of the topology that is generated by their union, the least upper bound is their intersection, and the ordering is reverse inclusion</p>
<p>You can check that, as with min / max and gcd / lcm, you can prove the commutativity and associativity of the infimum and supremum using only their characterizing axioms, together with le_refl and le_trans.</p>
<pre><code class="language-lean">example : x ⊓ y = y ⊓ x := by
  sorry

example : x ⊓ y ⊓ z = x ⊓ (y ⊓ z) := by
  sorry

example : x ⊔ y = y ⊔ x := by
  sorry

example : x ⊔ y ⊔ z = x ⊔ (y ⊔ z) := by
  sorry
</code></pre>
<p>You can find these theorems in the Mathlib as inf_comm, inf_assoc, sup_comm, and sup_assoc, respectively.</p>
<p>Another good exercise is to prove the absorption laws using only those axioms:</p>
<pre><code class="language-lean">theorem absorb1 : x ⊓ (x ⊔ y) = x := by
  sorry

theorem absorb2 : x ⊔ x ⊓ y = x := by
  sorry
</code></pre>
<p>These can be found in Mathlib with the names inf_sup_self and sup_inf_self.</p>
<p>A lattice that satisfies the additional identities x ⊓ (y ⊔ z) = (x ⊓ y) ⊔ (x ⊓ z) and x ⊔ (y ⊓ z) = (x ⊔ y) ⊓ (x ⊔ z) is called a distributive lattice. Lean knows about these too:</p>
<pre><code class="language-lean">variable {α : Type*} [DistribLattice α]
variable (x y z : α)

#check (inf_sup_left : x ⊓ (y ⊔ z) = x ⊓ y ⊔ x ⊓ z)
#check (inf_sup_right : (x ⊔ y) ⊓ z = x ⊓ z ⊔ y ⊓ z)
#check (sup_inf_left : x ⊔ y ⊓ z = (x ⊔ y) ⊓ (x ⊔ z))
#check (sup_inf_right : x ⊓ y ⊔ z = (x ⊔ z) ⊓ (y ⊔ z))
</code></pre>
<p>The left and right versions are easily shown to be equivalent, given the commutativity of ⊓ and ⊔. It is a good exercise to show that not every lattice is distributive by providing an explicit description of a nondistributive lattice with finitely many elements. It is also a good exercise to show that in any lattice, either distributivity law implies the other:</p>
<pre><code class="language-lean">variable {α : Type*} [Lattice α]
variable (a b c : α)

example (h : ∀ x y z : α, x ⊓ (y ⊔ z) = x ⊓ y ⊔ x ⊓ z) : a ⊔ b ⊓ c = (a ⊔ b) ⊓ (a ⊔ c) := by
  sorry

example (h : ∀ x y z : α, x ⊔ y ⊓ z = (x ⊔ y) ⊓ (x ⊔ z)) : a ⊓ (b ⊔ c) = a ⊓ b ⊔ a ⊓ c := by
  sorry
</code></pre>
<p>It is possible to combine axiomatic structures into larger ones. For example, a strict ordered ring consists of a commutative ring together with a partial order on the carrier satisfying additional axioms that say that the ring operations are compatible with the order:</p>
<pre><code class="language-lean">variable {R : Type*} [StrictOrderedRing R]
variable (a b c : R)

#check (add_le_add_left : a ≤ b → ∀ c, c + a ≤ c + b)
#check (mul_pos : 0 &lt; a → 0 &lt; b → 0 &lt; a * b)
</code></pre>
<p>Chapter 3 will provide the means to derive the following from mul_pos and the definition of &lt;:</p>
<p>#check (mul_nonneg : 0 ≤ a → 0 ≤ b → 0 ≤ a * b)
It is then an extended exercise to show that many common facts used to reason about arithmetic and the ordering on the real numbers hold generically for any ordered ring. Here are a couple of examples you can try, using only properties of rings, partial orders, and the facts enumerated in the last two examples:</p>
<pre><code class="language-lean">example (h : a ≤ b) : 0 ≤ b - a := by
  sorry

example (h: 0 ≤ b - a) : a ≤ b := by
  sorry

example (h : a ≤ b) (h' : 0 ≤ c) : a * c ≤ b * c := by
  sorry
</code></pre>
<p>Finally, here is one last example. A metric space consists of a set equipped with a notion of distance, dist x y, mapping any pair of elements to a real number. The distance function is assumed to satisfy the following axioms:</p>
<pre><code class="language-lean">variable {X : Type*} [MetricSpace X]
variable (x y z : X)

#check (dist_self x : dist x x = 0)
#check (dist_comm x y : dist x y = dist y x)
#check (dist_triangle x y z : dist x z ≤ dist x y + dist y z)
</code></pre>
<p>Having mastered this section, you can show that it follows from these axioms that distances are always nonnegative:</p>
<pre><code class="language-lean">example (x y : X) : 0 ≤ dist x y := by
  sorry
</code></pre>
<p>We recommend making use of the theorem nonneg_of_mul_nonneg_left. As you may have guessed, this theorem is called dist_nonneg in Mathlib.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter_1_introduction.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="chapter_10_integration_and_measure_theory.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter_1_introduction.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="chapter_10_integration_and_measure_theory.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
